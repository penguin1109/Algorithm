### 주제: BackTracking
#### BOJ 10971 외판원 순회2
첫 시도에는 pypy3으로만 통과가 되었다.   
일단 전형적인 백트래킹 문제 대로 bfs를 move()라는 함수를 이용해서 구현했으며, '길이 없을 수도 있다'라는 조건을 놓쳐서 그 부분을 확인하는 코드를 넣고  
출발지 제외 순회 완료 했음을 확인하는 부분에 오류가 있어서 그냥 sum(visit) == n일 때로 고쳤더니 답이 되었다.  
이제 python3로도 시간초과가 나지 않을 방법을 생각해 보아야 하는데, 일종의 greedy algorithm을 적용해서 재귀적으로 다음 단계를 불러오고자 할 때에 만약에 현재 ans보다 현재 추가되어서 나오는 비용이 더 크거나 작을 떄만 함수를 호출하도록 했다.  
그랬더니 2824ms에서 244ms로 줄고 python3로 통과가 되었다.
```py3
import sys
n = int(sys.stdin.readline())
board = []
for i in range(n):
    board.append(list(map(int, sys.stdin.readline().split())))


def move(start, temp, total):
    global visit, ans
    for i in range(n):
        if visit[i] == 0:
            if board[temp][i] != 0:
                if (total + board[temp][i]) <= ans:
                    visit[i] = 1
                    move(start, i, total + board[temp][i])
                    visit[i] = 0
    if sum(visit) == n:
        if board[temp][start] != 0:
            ans = min(ans, total+board[temp][start])

ans = 9999999999999
for i in range(n):
    visit = [0]*n
    visit[i] = 1
    move(i,i,0)
print(ans)
```

#### BOJ 2661번 좋은 수열
일단 좋은 수열을 판단하는 함수와 수열을 만들어주는 함수를 만들어서 수열을 오름차순으로 만들어 만약 valid한 수열이 있다고 하면 sys.exit()문으로 함수를 아얘 빠져 나가게 했다.  
그러나 수열을 만드는 과정에서 시간이 너무 오래 걸렸는지 python3와 pypy3모두 시간 초과가 발생했었다.  
알고리즘은 다 맞는 것 같아서 그냥 매번 함수를 재귀적으로 호출하기 전마다 valid한지 체크를 했는데 그 결과 시간초과가 없었다.  
```py3
import sys 
n = int(sys.stdin.readline())
def valid(strings):
    for i in range(1, len(strings)//2+1):
        for j in range(len(strings)-i):
            if strings[j:j+i] == strings[j+i:j+i*2]:
                return False
    return True


def make(made, v):
    if v == n-1:
        if valid(made):
            print(made)
            sys.exit()
        return
    for i in range(1, 4):
        if int(made[-1]) != i:
            if valid(made+str(i)):
                make(made+str(i), v+1)
    
make('1', 0)
```

#### 두 백트래킹 문제를 풀면서 얻은 결론은 재귀 한수는 호출할 수록 시간복잡도를 높인다는 점, 그렇기 때문에 중간 중간에 제한을 걸어서 **답이 될 수 없을 것들은 greedy의 관점으로** 중단해주는 것이 좋다.
