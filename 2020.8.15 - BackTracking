이 문제의 경우 백트래킹, 조합 모든 경우를 시도해 보았는데도 시간 초과와 메모리 초과가 발생하였다.
일단 그 전 index와 같은 간격만큼 x와 y좌표가 차이가 발생해서는 안되기 때문에 하나하나 일일이 해주다가 시간 초과가 발생하였고, 조합, 사실상 순열을 위해 permutations를 이용했는데 이 경우에 메모리 초과가 n=12일 때 발생하였다.

그러나 백준 사이트에서 pypy3로 풀었을 때에는 시간 초과가 발생하지 않았고, 정답이라고 나온 이후 python3로 풀어서 맞은 사람들의 소스 코드를 보니 전부 n의 범위에 맞게 답을 리스트에 저장해 출력한 것이었다.
### N-Queen
import sys
c = int(sys.stdin.readline())

def nqueen(v,before,left):
    global count
    if v == n:
        if len(set(left)) == n:
            count += 1
        return
    if v < n:
        for k in range(n):
            temp = True
            for l in range(1,v+1):
                if k == left[l-1]-(v-l+1) or k == left[l-1]+(v-l+1):
                    temp = False
                    break
            if temp:
                if k not in left:
                    nqueen(v+1, k, left+[k])
    
for _ in range(c):
    n = int(sys.stdin.readline())
    count = 0
    for i in range(n):
        nqueen(1, i, [i])
    print(count)

이 방법은 내가 푼 대로 한 것인데, 일단 pypy3의 속도로 볼 때 아래의 방법보다 속도가 빨랐다. 특히 이런 식으로 재귀적으로 문제를 풀 때에 리스트끼리 + 연산자로 충분히 .append()를 실행할 수 있다는 것은 매우 좋다.
import sys
t = int(sys.stdin.readline())
def nqueen(now, n):
    global count
    if len(now) == n:
        count += 1
        return
    candidate = [int(i) for i in range(n)]
    for i in range(len(now)):
        if now[i] in candidate:
            candidate.remove(now[i])
        dist = len(now)-i
        if now[i]-dist in candidate:
            candidate.remove(now[i]-dist)
        if now[i]+dist in candidate:
            candidate.remove(now[i]+dist)
    if candidate:
        for k in candidate:
            nqueen(now+[k], n)
    else:
        return
    
for _ in range(t):
    n = int(sys.stdin.readline())
    count = 0
    for i in range(n):
        nqueen([i], n)
    print(count)


### ClockSync

import sys,copy
sys.setrecursionlimit(10**9)
inf = float('inf')
c = int(sys.stdin.readline())
board = [[0,1,2],[3,7,9,11],[4,10,14,15],[0,4,5,6,7],[6,7,8,10,12],[0,2,14,15],[3,14,15],[4,5,7,14,15],[1,2,3,4,5],[3,4,5,9,13]]
def push(num, time):
    #같은 스위치는 총 4번까지 누를 수 있음
    for _ in range(time):
        for i in board[num]:
            clock[i] = (clock[i]+1)%4

def syncclock(now):
    #now는 누르고자하는 스위치의 번호이다.
    res = float('inf')
    if sum(clock)== 0:
        return 0
    if now == 10:
        return res
    for i in range(4):
        #syncclock(now)를 진행하게 되면 now번째 스위치를 누르게 될 때의 결과값이다.
        #따라서 재귀적으로 진행할 수 있도록 한다.
        res = min(res, i+syncclock(now+1))
        push(now,1)
    return res

for _ in range(c):
    clock = list(map(int, sys.stdin.readline().split()))
    clock = [i//3%4 for i in clock]
    ans = syncclock(0)
    if ans == inf:
        print(-1)
    else:
        print(ans)

처음 이 문제를 읽었을 때에 제일 난감했던 부분이 ‘언제를 -1로 출력하는 경우로 설정해야 하는가’이었다.
처음에는 총 4**10의 경우를 다 완전 탐색으로 진행해서 만약에 끝까지 정답이 최대로 설정한 초기 숫자에서 변함이 없으면 -1을 출력하는 방향으로 설정하려 했었다. 그러나 그렇게 하니 당연히 시간이 훨씬 오래 걸릴 수밖에 없었다.
여기서 시계의 바늘이 12,9,6,3의 4순환을 하기 때문에 스위치를 4번 이상 누르는 것은 무의미하다. 그리고 나는 한번에 동시에 어떤 스위치를 누를지 선택하는 방법이 맞을 것이라 생각했으나 너무 복잡할 뿐 아니라 각 스위치를 몇 번 누를지도 고려해 주어야 했기 때문에 그렇게 할 수는 없었다.
따라서 위와 같은 방법으로 풀었는데, 백트래킹 문제는 파이썬으로 모든 문제 푸는데에는 한계가 있음을 분명하게 알게 된 것 같다.

버튼을 눌러서 변화를 주는 함수(여기서 내가 원래 푼 방법은 deepcopy를 이용했기 때문에 메모리 초과 또한 발생했다.) 순차적으로 스위치를 각각 최대 3번씩 누르는 함수로 syncclock(num) (num은 스위치 번호)로 설정하여 현재 clock의 상태가 모두 12이면 0번 진행하면 되므로 return 0을, 현재 스위치 번호인 num이 10이면 return inf를, 그리고 이외의 상태에 대해서는 res = min(res, i+syncclock(now+1))을 진행하였다. 즉, syncclock(now+1)은 주어진 스위치를 누를때에 지금까지 총 몇번 눌러야 원하는 상태가 되는 지 int값을 return 하는 함수이다.

이렇게 해서 0번쨰 스위치부터 syncclock을 진행하여 return된 값에 따라 답을 출력하였다.

완전 탐색으로 4**10, 즉 각 스위치마다 (0,1,2,3)번, 총 4번 누르는 경우를 진행할 때 마다 min값으로 갱신한 것이다.
