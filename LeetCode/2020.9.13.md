#### LeetCode 15. 3Sum
- nums라는 사용할 수 있는 숫자로 이루어진 list를 제공하는데, 이때 3개의 수를 골라서 0이 될 수 있도록 해야 한다.
- 계속 시간 초과가 발생하고 누락되는 경우가 존재하다 보니까 밑에 있는 hint를 참고 했는데, hint에는 하나의 수를 정하고 그 수에 '-'를 붙인 값을 찾는 two-sum문제로 바꾸어서 해결하라고 나와 있었다.

```py3
class Solution:
    def threeSum(self, nums):
        result = set()
        seen = set()
        for i, val in enumerate(nums):
            if val in seen:
                continue
            seen.add(val)
            two_sum = -val
            val2_set = set()
            for j in nums[i+1:]:
                val2 = two_sum - j
                if val2 in val2_set:
                    result.add(tuple(sorted((val, val2, j))))
                val2_set.add(j)
        return result
```
- 위의 코드는 순차적으로 three_sum, two_sum, one이렇게 값을 빼면서 중복 또한 피할 수 있었던 코드였다.
- 그렇기 때문에 x값을 하나 지정하고 l,r의 포인터를 사용해서 index값으로 중복을 피하고 순차적으로 구하면 풀릴 것이라 생각했는데 계속 시간 초과가 발생하였다.

```py3
class Solution:
    def threeSum(self, nums):
        ans = set()
        def make(twosum, x,l,r):
            if nums[l]+nums[r] == twosum:
                if l!= r!= x:
                    ans.add(tuple(sorted((x,l,r))))
                return

            if l+1 < len(nums) and r-1 >= 0:make(twosum, x, l+1, r-1)
            if l+1 < len(nums):make(twosum, x, l+1, r)
            if r-1 >= 0:make(twosum, x, l, r-1)


        if len(nums) < 3:return []
        else:
            for i in range(len(nums)-1):
                make(-nums[i], i, i+1, len(nums)-1)
            answer = set()
            for i in ans:
                temp = []
                for f in i:
                    temp.append(nums[int(f)])
                answer.add(tuple(sorted(temp)))
        return (answer)
```
- 이와 같은 코드도 짜 보았는데 TimeLimitExceeded를 막을 수가 없었다.
- 위의 코드와 아래의 코드가 같은 원리를 이용하는 것 같음에도 불구하고 아래의 경우는 왜 답이 틀리는지 다시 확인해 봐야 할 것 같다.
**tuple은 list와 달리 자료의 데이터의 변형이나 반복등이 가능하기 때문에 사용하기에 더 유용하다.**

```py3
class Solution:
    def threeSum(self, nums):
        nums = sorted(nums)
        res = []
        if len(nums) < 3:
            return res
        else:
            for i in range(len(nums)-2):
                if i > 0 and nums[i] == nums[i-1]:continue
                l,r = i+1, len(nums)-1
                while l < r:
                    add = nums[l]+nums[r] + nums[i]
                    if add == 0:
                        res.append([nums[l], nums[r], nums[i]])
                        l += 1
                        r -= 1
                        while l < r and nums[l] == nums[l-1]:l+=1
                        while l < r and nums[r] == nums[r+1]:r-=1
                    elif add < 0:l+= 1
                    else:r-=1
        return res
```
- 마지막으로 해결한 방법인데, 이방법은 two-pointer을 이용한 방법이다. 혹은 이진 탐색의 방법을 약간 이용했다고 봐도 되는데, 그동안의 코드와의 차이라면 처음에 주어진 숫자 리스트를 sort했다는 것이다. 내가 계속 시도한 대로 중복을 없애기 위해 two-sum을 만들기 위해 하나 선택한 수의 index다음 index를 left pointer로, right pointer은 끝값으로 설정했다.
- 정렬한 상태이고 또 중복이 없어야 하기 때문에 그 이전의 값과 같다면, 즉 **현재 내 위치 이전에 사용한 값과 같으면** 또 계산해 줄 필요가 없다. 따라서 그런 경우에는 **포인터를 계속이동**해서 불필요한 계산을 줄여 주었다. 대신 중요한 것은 **이전의 값**과의 일치를 확인해야 한다는 것이다. 
- 그리고 while문을 이용해서 l < r일 떄만 해 주었고, 정렬한 리스트인 nums이기 때문에 합이 양수이면 r-=1을 해서 줄여주고 음수이면 l+=1을 해서 늘려준다.

