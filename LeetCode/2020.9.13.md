#### LeetCode 15. 3Sum
- nums라는 사용할 수 있는 숫자로 이루어진 list를 제공하는데, 이때 3개의 수를 골라서 0이 될 수 있도록 해야 한다.
- 계속 시간 초과가 발생하고 누락되는 경우가 존재하다 보니까 밑에 있는 hint를 참고 했는데, hint에는 하나의 수를 정하고 그 수에 '-'를 붙인 값을 찾는 two-sum문제로 바꾸어서 해결하라고 나와 있었다.

```py3
class Solution:
    def threeSum(self, nums):
        result = set()
        seen = set()
        for i, val in enumerate(nums):
            if val in seen:
                continue
            seen.add(val)
            two_sum = -val
            val2_set = set()
            for j in nums[i+1:]:
                val2 = two_sum - j
                if val2 in val2_set:
                    result.add(tuple(sorted((val, val2, j))))
                val2_set.add(j)
        return result
```
- 위의 코드는 순차적으로 three_sum, two_sum, one이렇게 값을 빼면서 중복 또한 피할 수 있었던 코드였다.
- 그렇기 때문에 x값을 하나 지정하고 l,r의 포인터를 사용해서 index값으로 중복을 피하고 순차적으로 구하면 풀릴 것이라 생각했는데 계속 시간 초과가 발생하였다.

```py3
class Solution:
    def threeSum(self, nums):
        ans = set()
        def make(twosum, x,l,r):
            if nums[l]+nums[r] == twosum:
                if l!= r!= x:
                    ans.add(tuple(sorted((x,l,r))))
                return

            if l+1 < len(nums) and r-1 >= 0:make(twosum, x, l+1, r-1)
            if l+1 < len(nums):make(twosum, x, l+1, r)
            if r-1 >= 0:make(twosum, x, l, r-1)


        if len(nums) < 3:return []
        else:
            for i in range(len(nums)-1):
                make(-nums[i], i, i+1, len(nums)-1)
            answer = set()
            for i in ans:
                temp = []
                for f in i:
                    temp.append(nums[int(f)])
                answer.add(tuple(sorted(temp)))
        return (answer)
```
- 이와 같은 코드도 짜 보았는데 TimeLimitExceeded를 막을 수가 없었다.
- 위의 코드와 아래의 코드가 같은 원리를 이용하는 것 같음에도 불구하고 아래의 경우는 왜 답이 틀리는지 다시 확인해 봐야 할 것 같다.
**tuple은 list와 달리 자료의 데이터의 변형이나 반복등이 가능하기 때문에 사용하기에 더 유용하다.**
